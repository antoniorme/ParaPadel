
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { AppNotification, NotificationType, NotificationSettings } from '../types';
import { supabase } from '../lib/supabase';
import { useAuth } from './AuthContext';

const LOCAL_NOTIF_KEY = 'padelpro_notifications_v1';
const LOCAL_SETTINGS_KEY = 'padelpro_notif_settings_v1';

interface NotificationContextType {
    notifications: AppNotification[];
    unreadCount: number;
    settings: NotificationSettings;
    addNotification: (userId: string, type: NotificationType, title: string, message: string, link?: string, meta?: any) => Promise<void>;
    markAsRead: (id: string) => Promise<void>;
    markAllAsRead: () => Promise<void>;
    deleteNotification: (id: string) => Promise<void>;
    updateSettings: (newSettings: Partial<NotificationSettings>) => void;
}

const defaultSettings: NotificationSettings = {
    invites: true,
    matchStart: true,
    results: true,
    system: true
};

const NotificationContext = createContext<NotificationContextType>({
    notifications: [],
    unreadCount: 0,
    settings: defaultSettings,
    addNotification: async () => {},
    markAsRead: async () => {},
    markAllAsRead: async () => {},
    deleteNotification: async () => {},
    updateSettings: () => {},
});

export const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { user, isOfflineMode } = useAuth();
    const [notifications, setNotifications] = useState<AppNotification[]>([]);
    const [settings, setSettings] = useState<NotificationSettings>(defaultSettings);

    // Identify current user/player context
    // In simulation mode, we use the stored player ID
    const getCurrentRecipientId = useCallback(() => {
        if (user) return user.id; // Admin/Auth User
        return localStorage.getItem('padel_sim_player_id') || 'guest'; // Player Simulator
    }, [user]);

    // Load Settings
    useEffect(() => {
        const stored = localStorage.getItem(LOCAL_SETTINGS_KEY);
        if (stored) setSettings(JSON.parse(stored));
    }, []);

    // Load Notifications
    const loadNotifications = useCallback(async () => {
        const recipientId = getCurrentRecipientId();
        
        if (isOfflineMode) {
            const stored = localStorage.getItem(LOCAL_NOTIF_KEY);
            if (stored) {
                const all: AppNotification[] = JSON.parse(stored);
                // Filter for current user context
                const mine = all.filter(n => n.userId === recipientId);
                setNotifications(mine.sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()));
            }
            return;
        }

        try {
            const { data, error } = await supabase
                .from('notifications')
                .select('*')
                .eq('user_id', recipientId)
                .order('created_at', { ascending: false });
            
            if (data) {
                const mapped: AppNotification[] = data.map(n => ({
                    id: n.id,
                    userId: n.user_id,
                    type: n.type as NotificationType,
                    title: n.title,
                    message: n.message,
                    link: n.link,
                    read: n.read,
                    createdAt: n.created_at,
                    meta: n.meta
                }));
                setNotifications(mapped);
            }
        } catch (e) {
            console.error("Error loading notifications:", e);
        }
    }, [isOfflineMode, getCurrentRecipientId]);

    useEffect(() => {
        loadNotifications();
        
        // Poll for updates in offline/sim mode (or if realtime is tricky)
        const interval = setInterval(loadNotifications, 5000); 
        return () => clearInterval(interval);
    }, [loadNotifications]);

    // --- ACTIONS ---

    const addNotification = async (userId: string, type: NotificationType, title: string, message: string, link?: string, meta?: any) => {
        // Check settings preference (Simulated check, ideally backend does this)
        // Note: We can't check the recipient's settings easily here without fetching them, 
        // so we assume send and filter on display or check local if self.
        
        const newNotif: AppNotification = {
            id: isOfflineMode ? `local-n-${Date.now()}` : '', // ID generated by DB or temp
            userId,
            type,
            title,
            message,
            link,
            read: false,
            createdAt: new Date().toISOString(),
            meta
        };

        if (isOfflineMode) {
            const stored = localStorage.getItem(LOCAL_NOTIF_KEY);
            const all: AppNotification[] = stored ? JSON.parse(stored) : [];
            all.push(newNotif);
            localStorage.setItem(LOCAL_NOTIF_KEY, JSON.stringify(all));
            loadNotifications();
        } else {
            await supabase.from('notifications').insert([{
                user_id: userId,
                type,
                title,
                message,
                link,
                read: false,
                meta
            }]);
            loadNotifications();
        }
    };

    const markAsRead = async (id: string) => {
        if (isOfflineMode) {
            const stored = localStorage.getItem(LOCAL_NOTIF_KEY);
            if (stored) {
                const all: AppNotification[] = JSON.parse(stored);
                const updated = all.map(n => n.id === id ? { ...n, read: true } : n);
                localStorage.setItem(LOCAL_NOTIF_KEY, JSON.stringify(updated));
                loadNotifications();
            }
        } else {
            // Optimistic update
            setNotifications(prev => prev.map(n => n.id === id ? { ...n, read: true } : n));
            await supabase.from('notifications').update({ read: true }).eq('id', id);
        }
    };

    const markAllAsRead = async () => {
        const recipientId = getCurrentRecipientId();
        if (isOfflineMode) {
            const stored = localStorage.getItem(LOCAL_NOTIF_KEY);
            if (stored) {
                const all: AppNotification[] = JSON.parse(stored);
                const updated = all.map(n => n.userId === recipientId ? { ...n, read: true } : n);
                localStorage.setItem(LOCAL_NOTIF_KEY, JSON.stringify(updated));
                loadNotifications();
            }
        } else {
            setNotifications(prev => prev.map(n => ({ ...n, read: true })));
            await supabase.from('notifications').update({ read: true }).eq('user_id', recipientId);
        }
    };

    const deleteNotification = async (id: string) => {
        if (isOfflineMode) {
            const stored = localStorage.getItem(LOCAL_NOTIF_KEY);
            if (stored) {
                const all: AppNotification[] = JSON.parse(stored);
                const updated = all.filter(n => n.id !== id);
                localStorage.setItem(LOCAL_NOTIF_KEY, JSON.stringify(updated));
                loadNotifications();
            }
        } else {
            setNotifications(prev => prev.filter(n => n.id !== id));
            await supabase.from('notifications').delete().eq('id', id);
        }
    };

    const updateSettings = (newSettings: Partial<NotificationSettings>) => {
        const updated = { ...settings, ...newSettings };
        setSettings(updated);
        localStorage.setItem(LOCAL_SETTINGS_KEY, JSON.stringify(updated));
    };

    const unreadCount = notifications.filter(n => !n.read).length;

    return (
        <NotificationContext.Provider value={{
            notifications,
            unreadCount,
            settings,
            addNotification,
            markAsRead,
            markAllAsRead,
            deleteNotification,
            updateSettings
        }}>
            {children}
        </NotificationContext.Provider>
    );
};

export const useNotifications = () => useContext(NotificationContext);
